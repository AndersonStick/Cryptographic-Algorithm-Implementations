# -*- coding: utf-8 -*-
"""Cifrado de Hill.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15o7RgCiWH6zUie7QAAObxbbcOFKNs4o_

# **Cifrado Taller Cifrado de Hill HOMEWORK**
## Anderson Stick Barrera Tovar
### 1000623506

Implementar el algoritmo de cifrado de bloques de Hill en Python (o en el lenguaje de su elección) utilizando el módulo 26. Asegúrese de validar que la matriz tiene inversa modular, es decir, que el determinante es diferente a 0 y que el determinante sea coprimo con 26, es deci,r que gcd(detA,26)=1.

El algoritmo debe recibir como entrada para cifrar:

- El mensaje en texto claro
- La clave (matriz de 2x2)

Para decifrar:

- Mensaje cifrado
- La clave (matriz de 2x2)
Cargar en esta tarea un archivo ZIP con lo siguiente:

Archivo Python
Pequeño video o screenshot en donde se muestre funcionar el algoritmo
"""

import numpy as np
from math import gcd

# Función para convertir texto a números
def texto_a_numeros(texto):
    return [ord(caracter) - 65 for caracter in texto]

# Función para convertir números a texto
def numeros_a_texto(numeros):
    return ''.join([chr(numero + 65) for numero in numeros])

# Función para validar si una matriz tiene inversa modular
def matriz_tiene_inversa_modular(matriz):
    det = np.linalg.det(matriz) % 26
    if det == 0:
        return False
    if gcd(int(det), 26) == 1:
        return True
    return False

# Función para cifrar utilizando el algoritmo de Hill
def cifrar(texto, clave):
    texto = texto.replace(" ", "").upper() # Eliminar espacios y convertir a mayúsculas
    clave = np.array(clave)
    if clave.shape != (2, 2):
        raise ValueError("La clave debe ser una matriz 2x2")
    if not matriz_tiene_inversa_modular(clave):
        raise ValueError("La matriz de clave no tiene inversa modular")
    tamaño = len(texto)
    if tamaño % 2 != 0:
        texto += 'X' # Añadir una 'X' al final si la longitud del texto es impar
        tamaño += 1
    texto_numeros = texto_a_numeros(texto)
    texto_numeros = np.array(texto_numeros)
    texto_numeros = texto_numeros.reshape(-1, 2)
    texto_cifrado = ""
    for bloque in texto_numeros:
        bloque_cifrado = np.dot(bloque, clave) % 26
        texto_cifrado += numeros_a_texto(bloque_cifrado)
    return texto_cifrado

def matriz_inversa_mod26(matriz):
    a, b, c, d = matriz[0][0], matriz[0][1], matriz[1][0], matriz[1][1]
    det = (a*d - b*c) % 26
    det_inv = pow(det, -1, 26)
    inversa = [[(d * det_inv) % 26, (-b * det_inv) % 26],
               [(-c * det_inv) % 26, (a * det_inv) % 26]]
    return inversa

# Función para descifrar utilizando el algoritmo de Hill
def descifrar(texto_cifrado, clave):
    clave = np.array(clave)
    if clave.shape != (2, 2):
        raise ValueError("La clave debe ser una matriz 2x2")
    if not matriz_tiene_inversa_modular(clave):
        raise ValueError("La matriz de clave no tiene inversa modular")
    tamaño = len(texto_cifrado)
    if tamaño % 2 != 0:
        raise ValueError("El texto cifrado no tiene longitud válida")
    texto_numeros = texto_a_numeros(texto_cifrado)
    texto_numeros = np.array(texto_numeros)
    texto_numeros = texto_numeros.reshape(-1, 2)
    texto_descifrado = ""
    for bloque in texto_numeros:
        bloque_descifrado = np.dot(bloque, inversa) % 26
        bloque_descifrado = np.round(bloque_descifrado).astype(int)  # Redondear a enteros
        texto_descifrado += numeros_a_texto(bloque_descifrado)
    return texto_descifrado

"""**EJEMPLO CLASE CIFRAR JULY**"""

# Ejemplo de uso
if __name__ == "__main__":
    mensaje_original = "JULY"
    clave = [[11, 8], [3, 7]]

    # Cifrar el mensaje
    mensaje_cifrado = cifrar(mensaje_original, clave)
    print("Mensaje cifrado:", mensaje_cifrado)

"""**EJEMPLO CLASE MATRIZ**


\begin{matrix}
[11, & 8] \\
[3, & 7] \\
\end{matrix}

"""

# Ejemplo de uso
matriz = [[11, 8],
          [3, 7]]

inversa = matriz_inversa_mod26(matriz)
print("Matriz inversa módulo 26:")
for fila in inversa:
    print(fila)

"""**EJERCICIO CLASE DESCIFRAR VKFZRVWTIAZSMISGKA**"""

# Mensaje cifrado
mensaje_cifrado = "VKFZRVWTIAZSMISGKA"

# Descifrar el mensaje
mensaje_descifrado = descifrar(mensaje_cifrado, inversa)
print("Mensaje descifrado:", mensaje_descifrado)

"""**Código escalado a matrices que tengan inversa modular > 2x2**"""

# Función para convertir texto a números
def texto_a_numeros(texto):
    return [ord(caracter) - 65 for caracter in texto]

# Función para convertir números a texto
def numeros_a_texto(numeros):
    return ''.join([chr(numero + 65) for numero in numeros])

# Función para validar si una matriz tiene inversa modular
def matriz_tiene_inversa_modular(matriz):
    det = np.linalg.det(matriz) % 26
    if det == 0:
        return False
    if gcd(int(det), 26) == 1:
        return True
    return False

# Función para cifrar utilizando el algoritmo de Hill
def cifrar(texto, clave):
    texto = texto.replace(" ", "").upper() # Eliminar espacios y convertir a mayúsculas
    clave = np.array(clave)
    if clave.shape[0] != clave.shape[1]:
        raise ValueError("La clave debe ser una matriz cuadrada")
    if not matriz_tiene_inversa_modular(clave):
        raise ValueError("La matriz de clave no tiene inversa modular")
    tamaño = len(texto)
    if tamaño % clave.shape[0] != 0:
        texto += 'X' * (clave.shape[0] - (tamaño % clave.shape[0])) # Añadir X al final si la longitud del texto no es un múltiplo de la dimensión de la clave
        tamaño = len(texto)
    texto_numeros = texto_a_numeros(texto)
    texto_numeros = np.array(texto_numeros)
    texto_numeros = texto_numeros.reshape(-1, clave.shape[0])
    texto_cifrado = ""
    for bloque in texto_numeros:
        bloque_cifrado = np.dot(bloque, clave) % 26
        texto_cifrado += numeros_a_texto(bloque_cifrado)
    return texto_cifrado

# Función para calcular la matriz inversa modular 26
def matriz_inversa_mod26(matriz):
    det = int(round(np.linalg.det(matriz))) % 26
    if det == 0:
        raise ValueError("La matriz no tiene inversa modular")
    det_inv = pow(det, -1, 26)
    inversa = (det_inv * np.round(det * np.linalg.inv(matriz)).astype(int)) % 26
    return inversa

def descifrar(texto_cifrado, clave):
    clave = np.array(clave)
    if clave.shape[0] != clave.shape[1]:
        raise ValueError("La clave debe ser una matriz cuadrada")

    # Verificar si la matriz de clave tiene una inversa modular válida
    if not matriz_tiene_inversa_modular(clave):
        raise ValueError("La matriz de clave no tiene inversa modular válida")

    try:
        inversa = matriz_inversa_mod26(clave)
    except ValueError as e:
        raise ValueError("La matriz de clave no tiene inversa modular válida") from e

    tamaño = len(texto_cifrado)
    if tamaño % clave.shape[0] != 0:
        raise ValueError("El texto cifrado no tiene longitud válida")

    texto_numeros = texto_a_numeros(texto_cifrado)
    texto_numeros = np.array(texto_numeros)
    texto_numeros = texto_numeros.reshape(-1, clave.shape[0])
    texto_descifrado = ""

    for bloque in texto_numeros:
        bloque_descifrado = np.dot(bloque, inversa) % 26
        texto_descifrado += numeros_a_texto(bloque_descifrado)

    return texto_descifrado

if __name__ == "__main__":
    mensaje_original = "ANDERSONBARRERA"
    clave_3x3 = [[6, 24, 1], [13, 16, 10], [20, 17, 15]]  # Ejemplo de una matriz 3x3

    # Verificar si la matriz de clave tiene inversa modular válida
    if not matriz_tiene_inversa_modular(clave_3x3):
        raise ValueError("La matriz de clave no tiene inversa modular válida")

    # Cifrar el mensaje
    mensaje_cifrado = cifrar(mensaje_original, clave_3x3)
    print("Mensaje cifrado:", mensaje_cifrado)

inversa_3x3 = matriz_inversa_mod26(clave_3x3)
print("Matriz inversa módulo 26:")
for fila in inversa_3x3:
    print(fila)

if __name__ == "__main__":
    mensaje_cifrado = "VZTHYCNPDPPJLES"
    clave_3x3 = [[22, 19, 13], [0, 22, 3], [6, 5, 12]]  # Clave utilizada para cifrar el mensaje

    # Descifrar el mensaje
    mensaje_descifrado = descifrar(mensaje_cifrado, clave_3x3)
    print("Mensaje descifrado:", mensaje_descifrado)