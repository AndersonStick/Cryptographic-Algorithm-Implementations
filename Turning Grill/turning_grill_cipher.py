# -*- coding: utf-8 -*-
"""Turning Grill Cipher.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Oc9HwtNNhnvvLMCKbmIHjubWGsI_VzA-

# **Taller Turning Grill Cipher HOMEWORK**
## Anderson Stick Barrera Tovar
### 1000623506

Implementar el algoritmo de Turning Grille utilizando Python, en donde se reciben los siguientes parámetros:

- Tamaño de la retícula (cuadrada, por ejemplo 2 indica que es de 2x2)
- Dirección de la rotación (sentido de las manecillas del reloj o sentido contrario, por ejemplo 1 ó 0 respectivamente)
- Modo (cifra miento o desciframiento, por ejemplo 1 ó 0 respectivamente)
- Cantidad y distribución de los hoyos (se recomienda ingresar únicamente las celdas de la matriz en la que hay hoyos)
- Mensaje a (de)cifrar

Subir un ZIP con lo siguiente:

- Script de python
- Pantallazo o video en donde se muestre funcionando el script

## 1. Grilla y Mensaje

En el método de _Turning Grille_, en lugar de utilizar la convencional llave de texto, se emplea una grilla que consiste en una matriz cuadrada con perforaciones que se gira en una dirección arbitraria, actuando como la "llave" o el "layout". El proceso comienza solicitando al usuario el ***mensaje*** (`msg`) y las especificaciones de la grilla (su ***tamaño*** `n`, la ***cantidad de perforaciones*** `x`, y la ***dirección de rotación*** `x`). El mensaje se convierte completamente a mayúsculas, se eliminan los espacios (si los hay) y se agrega el caracter $X$ para rellenar si es necesario:
"""

import numpy as np

msg = input('\nIngrese el mensaje: ')     # Solicita al usuario que ingrese el mensaje
msg = msg.replace(" ", "")                # Elimina los espacios en blanco del mensaje
msg = msg.upper()                         # Convierte el mensaje a mayúsculas

n = int(input('\nIngrese el tamaño (n) de la grilla: '))  # Solicita al usuario que ingrese el tamaño de la retícula
h = int(input('Ingrese la cantidad de huecos: '))          # Solicita al usuario que ingrese la cantidad de huecos

# Grilla ("Llave")
K = np.zeros((n, n))  # Crea una matriz de ceros de tamaño n x n que servirá como la "llave" para el cifrado

# Pide al usuario que ingrese la posición de cada hueco en la grilla
print('Ingrese la posición (i,j) de cada hueco:')
for num in range(0,h):
  print('--------')
  i = int(input('i:'))  # Solicita al usuario que ingrese la fila del hueco
  j = int(input('j:'))  # Solicita al usuario que ingrese la columna del hueco
  K[i, j] = 1;  # Marca el hueco en la posición (i, j) de la matriz K

# Muestra la grilla (llave) creada con los huecos marcados
print('\nGrilla:')
print(K)

# Solicita al usuario que ingrese el sentido de rotación
rot = int(input('\nIngrese el sentido de rotación:\n 1. Izquierda \n 2. Derecha \n'))

# Rellena el mensaje con caracteres 'X' si es necesario para que su longitud sea igual al tamaño de la grilla
while len(msg) < n*n:
  msg += 'X'  # Añade caracteres 'X' al final del mensaje hasta que su longitud sea igual al tamaño de la grilla

"""## 2. Diccionario de letras a Números y Viceversa

_**Diccionarios:**_

Usamos el alfabeto de 26 caracteres ($ABCDEFGHIJKLMNOPQRSTUVWXYZ$).

* `L2N` ("Letter to Number") permite mapear cada letra mayúscula a un número entero.
* `N2L` ("Number to Letter") es el opuesto de `L2N`: a cada número le asigna una letra mayúscula.
"""

L2N = {
  'A': 0,  'B': 1,  'C': 2,  'D': 3,  'E': 4,  'F': 5,  'G': 6,  'H': 7,
  'I': 8,  'J': 9,  'K': 10, 'L': 11, 'M': 12, 'N': 13, 'O': 14, 'P': 15,
  'Q': 16, 'R': 17, 'S': 18, 'T': 19, 'U': 20, 'V': 21, 'W': 22, 'X': 23,
  'Y': 24, 'Z': 25
}

N2L = {v: k for k, v in L2N.items()}

"""_**Funciones:**_
* `matrixLeft()` y `matrixRight()` permiten rotar una matriz $K_{n \times n}$ a la izquierda y a la derecha, respectivamente. Esta matriz $K$ es la grilla.
* `msgToMatrix()` permite convertir un mensaje de string a matriz cuadrada de tamaño `n` para su tratamiento en el algoritmo ($msg \rightarrow M_{n \times n}$).
* `getValues()` permite recuperar las letras de la matriz $M$ en las posiciones "visibles" a través de la grilla $K$ haciendo uso del diccionario `N2L`.
* `hideValues()` hace un proceso inverso: oculta las letras usando el diccionario `L2N`.
"""

# Función para rotar la matriz hacia la izquierda
def matrixLeft(K,n):
  O =  np.zeros((n, n))  # Crea una nueva matriz de ceros con las mismas dimensiones que K
  for i in range(0,n):
    for j in range(0,n):
      O[n-(j+1)][i] = K[i][j]  # Rota la matriz K hacia la izquierda y la guarda en la matriz O
  return O

# Función para rotar la matriz hacia la derecha
def matrixRight(K,n):
  O =  np.zeros((n, n))  # Crea una nueva matriz de ceros con las mismas dimensiones que K
  for i in range(0,n):
    for j in range(0,n):
      O[j][n-(i+1)] = K[i][j]  # Rota la matriz K hacia la derecha y la guarda en la matriz O
  return O

# Función para convertir el mensaje en una matriz de números según una tabla de correspondencia
def msgToMatrix(msg,n):
  M = np.zeros((n, n))  # Crea una nueva matriz de ceros de dimensiones n x n
  for l in range(0, len(msg)):
    i = (int(l/n))  # Calcula la fila correspondiente al índice l del mensaje
    j = (int(l%n))  # Calcula la columna correspondiente al índice l del mensaje
    M[i][j] = L2N[msg[l]]  # Asigna el valor numérico correspondiente a la letra del mensaje a la posición (i, j) de la matriz M
  return M

# Función para obtener los valores ocultos en la grilla
def getValues(M,K,n):
  out = ""
  for i in range(0,n):
    for j in range(0,n):
      if K[i][j] == 1:  # Si en la posición (i, j) de la grilla K hay un 1, indica que hay un valor oculto
        out += N2L[M[i][j]]  # Añade la letra correspondiente al valor numérico en la posición (i, j) de la matriz M
  return out

# Función para ocultar valores en la grilla
def hideValues(l,K,n,M):
  count = 0
  for i in range(0,n):
    for j in range(0,n):
      if K[i][j] == 1:  # Si en la posición (i, j) de la grilla K hay un 1, indica que se debe ocultar un valor
        M[i][j] = L2N[l[count]]  # Asigna el valor numérico correspondiente a la letra en la posición count de la lista l a la posición (i, j) de la matriz M
        count += 1  # Incrementa el contador para pasar a la siguiente letra de la lista l
  return M

"""## 3. Cifrar

Para el proceso de encripción se ubican las letras del mensaje `msg` en la matriz $M$ siguiendo la guía de los huecos de la grilla $K$ y el sentido de rotación `rot`. El mensaje cifrado será entonces la matriz $M$ leída fila por fila, de arriba hacia abajo.
"""

def encrypt(msg,K,n,h,rot):
  M = np.zeros((n, n))  # Crea una matriz de ceros de tamaño n x n que servirá para cifrar el mensaje
  for x in range(0, 4):  # Itera cuatro veces (4 vueltas de la grilla)
    l1 = int((len(msg)/h) * x)  # Calcula el índice de inicio de la porción de mensaje a cifrar en esta vuelta de la grilla
    l2 = int((len(msg)/h) * x) + h  # Calcula el índice de fin de la porción de mensaje a cifrar en esta vuelta de la grilla

    l = msg[l1:l2]  # Extrae la porción de mensaje a cifrar en esta vuelta de la grilla

    M = hideValues(l, K, n, M)  # Oculta la porción de mensaje en la matriz M utilizando la grilla K
    if rot == 1:  # Si el sentido de rotación es izquierda
      K = matrixLeft(K, n)  # Rota la grilla hacia la izquierda
    if rot == 2:  # Si el sentido de rotación es derecha
      K = matrixRight(K, n)  # Rota la grilla hacia la derecha

  out = ""  # Inicializa una cadena vacía para almacenar el mensaje cifrado
  for i in range(0,n):
    for j in range(0,n):
      out += N2L[M[i][j]]  # Convierte los números ocultos en letras y los concatena a la cadena de salida

  return out  # Devuelve el mensaje cifrado como una cadena de texto

"""## 4. Descifrar

Para desencriptar, se inicia poniendo el mensaje `msg` en forma de matriz ($M$). Luego, se comienzan a recuperar los valores que marcan los huecos de la grilla $K$ (con la función `getValues()`); por último, se rota la grilla y se repite el proceso. El resultado final (`out`) será la concatenación de todas las letras recuperadas, en orden.
"""

def decrypt(msg,K,n,h,rot):
  M = msgToMatrix(msg, n)  # Convierte el mensaje cifrado en una matriz utilizando la función msgToMatrix
  out = ""  # Inicializa una cadena vacía para almacenar el mensaje descifrado

  for giro in range(0, 4):  # Itera cuatro veces (4 vueltas de la grilla)
    out += getValues(M,K,n)  # Obtiene los valores ocultos en la grilla y los añade al mensaje descifrado
    if rot == 1:  # Si el sentido de rotación es izquierda
      K = matrixLeft(K, n)  # Rota la grilla hacia la izquierda
    if rot == 2:  # Si el sentido de rotación es derecha
      K = matrixRight(K, n)  # Rota la grilla hacia la derecha

  return out  # Devuelve el mensaje descifrado como una cadena de texto

"""## 4. Impresión final

Se pide si quiere cifrar o descifrar
"""

print("TURNING GRILL CIPHER \nSeleccione una opción")
choice = int(input(" 1. Cifrar \n 2. Descifrar \n"))

if choice == 1:
  print("\n---------------\n\nMensaje Original: " + msg)
  print("Grilla: ")
  print(K)
  if rot == 1:
    print("Rotación: Izquierda")
  if rot == 2:
    print("Rotación: Derecha")

  out = encrypt(msg,K,n,h,rot)
  print("\n---------------\n\nMensaje Cifrado: " + out)

elif choice == 2:
  print("\n---------------\n\nMensaje Cifrado: " + msg)
  print("Grilla: ")
  print(K)
  if rot == 1:
    print("Rotación: Izquierda")
  if rot == 2:
    print("Rotación: Derecha")

  out = decrypt(msg,K,n,h,rot)
  print("\n---------------\n\nMensaje descifrado: " + out)